/*
 * Copyright (c) 2023 Maple Wu <justmaplewu@gmail.com>
 *   National Electronics and Computer Technology Center, Thailand
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package plugins

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"path/filepath"
	"testing"

	zcore "github.com/go-zing/gozz-core"
)

func parseFunc(t *testing.T, str string) *funcType {
	t.Helper()
	v, err := parser.ParseFile(token.NewFileSet(), "", fmt.Sprintf(`package t;func t%s{}`, str), parser.ParseComments)
	if err != nil {
		t.Fatal(err)
	}
	ft, ok := v.Scope.Lookup("t").Decl.(*ast.FuncDecl)
	if !ok {
		t.Fatalf("%T", ft)
	}
	return (*funcType)(ft.Type)
}

func TestFuncTypeReturns(t *testing.T) {
	cases := [][4]interface{}{
		{"()(int,error)", true, "return", ""},
		{"()(int,int)", false, "", ""},
		{"()(int)", true, "return", ",nil"},
		{"()(error)", true, "return nil,", ""},
		{"()()", true, "", ";return nil,nil"},
		{"()(int,int,int)", false, "", ""},
	}

	for _, c := range cases {
		ft := parseFunc(t, c[0].(string))
		r, r2, valid := ft.returns()
		if valid != c[1] || r != c[2] || r2 != c[3] {
			t.Fatal(c, valid, r, r2)
		}
	}
}

func TestFuncTypeParams(t *testing.T) {
	cases := [][4]interface{}{
		{"(context.Context,int)", true, "ctx,in", paramDecode},
		{"(context.Context,*int)", true, "ctx,&in", paramDecode},
		{"(int)", true, "in", paramDecode},
		{"(*int)", true, "&in", paramDecode},
		{"(context.Context)", true, "ctx", ""},
		{"(*context.Context)", true, "&in", paramDecode},
		{"()", true, "", ""},
		{"(int,int)", false, "", ""},
		{"(context.Context,int,int)", false, "", ""},
	}

	for _, c := range cases {
		ft := parseFunc(t, c[0].(string))
		param, decode, _, valid := ft.params()
		if valid != c[1] || param != c[2] || decode != c[3] {
			t.Fatal(c, valid, param, decode)
		}
	}
}

const (
	testApiData = `package api02

import (
	"context"
)

//go:generate gozz run -p "api" ./

// +zz:api:./:path={{ snake .FieldName }}
type (
	T interface {
		// +zz:api:get
		Empty()
		// +zz:api:get
		Ret() (ret int)
		// +zz:api:get
		Error() (err error)
		// +zz:api:get
		RetError() (ret int, err error)
		// +zz:api:get
		Context(ctx context.Context)
		// +zz:api:get
		ContextRet(ctx context.Context) (ret int)
		// +zz:api:get
		ContextError(ctx context.Context) (err error)
		// +zz:api:get
		ContextRetError(ctx context.Context) (ret int, err error)
		// +zz:api:get
		Param(param int)
		// +zz:api:get
		ParamRet(param int) (ret error)
		// +zz:api:get
		ParamError(param int) (err error)
		// +zz:api:get
		ParamRetError(param int) (ret int, err error)
		// +zz:api:get
		ContextParam(ctx context.Context, param int)
		// +zz:api:get
		ContextParamRet(ctx context.Context, param int) (ret int)
		// +zz:api:get
		ContextParamError(ctx context.Context, param int) (err error)
		// +zz:api:get
		ContextParamRetError(ctx context.Context, param int) (ret int, err error)
		// +zz:api:get
		ComplexParam(param map[context.Context][]struct {
			Field []func(context.Context) interface {
				context.Context
			}
		})
		// +zz:api:get
		PtrParam(*int)
	}
)
`

	testApiRetData = `// Code generated by gozz:api github.com/go-zing/gozz. DO NOT EDIT.

package api02

import (
	"context"
)

var _ = context.Context(nil)

type Apis struct {
	T T
}

func (s Apis) Iterate(fn func(interface{}, []map[string]interface{})) {
	for _, f := range []func() (interface{}, []map[string]interface{}){
		s._T,
	} {
		fn(f())
	}
}

func (s Apis) _T() (interface{}, []map[string]interface{}) {
	t := s.T
	return &t, []map[string]interface{}{
		{
			"name":     "Empty",
			"resource": "get",
			"options": map[string]string{
				"path": "empty",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				t.Empty()
				return nil, nil
			},
		},
		{
			"name":     "Ret",
			"resource": "get",
			"options": map[string]string{
				"path": "ret",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				return t.Ret(), nil
			},
		},
		{
			"name":     "Error",
			"resource": "get",
			"options": map[string]string{
				"path": "error",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				return nil, t.Error()
			},
		},
		{
			"name":     "RetError",
			"resource": "get",
			"options": map[string]string{
				"path": "ret_error",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				return t.RetError()
			},
		},
		{
			"name":     "Context",
			"resource": "get",
			"options": map[string]string{
				"path": "context",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				t.Context(ctx)
				return nil, nil
			},
		},
		{
			"name":     "ContextRet",
			"resource": "get",
			"options": map[string]string{
				"path": "context_ret",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				return t.ContextRet(ctx), nil
			},
		},
		{
			"name":     "ContextError",
			"resource": "get",
			"options": map[string]string{
				"path": "context_error",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				return nil, t.ContextError(ctx)
			},
		},
		{
			"name":     "ContextRetError",
			"resource": "get",
			"options": map[string]string{
				"path": "context_ret_error",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				return t.ContextRetError(ctx)
			},
		},
		{
			"name":     "Param",
			"resource": "get",
			"options": map[string]string{
				"path": "param",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				var in int
				if err := dec(&in); err != nil {
					return nil, err
				}
				t.Param(in)
				return nil, nil
			},
		},
		{
			"name":     "ParamRet",
			"resource": "get",
			"options": map[string]string{
				"path": "param_ret",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				var in int
				if err := dec(&in); err != nil {
					return nil, err
				}
				return nil, t.ParamRet(in)
			},
		},
		{
			"name":     "ParamError",
			"resource": "get",
			"options": map[string]string{
				"path": "param_error",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				var in int
				if err := dec(&in); err != nil {
					return nil, err
				}
				return nil, t.ParamError(in)
			},
		},
		{
			"name":     "ParamRetError",
			"resource": "get",
			"options": map[string]string{
				"path": "param_ret_error",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				var in int
				if err := dec(&in); err != nil {
					return nil, err
				}
				return t.ParamRetError(in)
			},
		},
		{
			"name":     "ContextParam",
			"resource": "get",
			"options": map[string]string{
				"path": "context_param",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				var in int
				if err := dec(&in); err != nil {
					return nil, err
				}
				t.ContextParam(ctx, in)
				return nil, nil
			},
		},
		{
			"name":     "ContextParamRet",
			"resource": "get",
			"options": map[string]string{
				"path": "context_param_ret",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				var in int
				if err := dec(&in); err != nil {
					return nil, err
				}
				return t.ContextParamRet(ctx, in), nil
			},
		},
		{
			"name":     "ContextParamError",
			"resource": "get",
			"options": map[string]string{
				"path": "context_param_error",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				var in int
				if err := dec(&in); err != nil {
					return nil, err
				}
				return nil, t.ContextParamError(ctx, in)
			},
		},
		{
			"name":     "ContextParamRetError",
			"resource": "get",
			"options": map[string]string{
				"path": "context_param_ret_error",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				var in int
				if err := dec(&in); err != nil {
					return nil, err
				}
				return t.ContextParamRetError(ctx, in)
			},
		},
		{
			"name":     "ComplexParam",
			"resource": "get",
			"options": map[string]string{
				"path": "complex_param",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				var in map[context.Context][]struct {
					Field []func(context.Context) interface {
						context.Context
					}
				}
				if err := dec(&in); err != nil {
					return nil, err
				}
				t.ComplexParam(in)
				return nil, nil
			},
		},
		{
			"name":     "PtrParam",
			"resource": "get",
			"options": map[string]string{
				"path": "ptr_param",
			},
			"invoke": func(ctx context.Context, dec func(interface{}) error) (interface{}, error) {
				var in int
				if err := dec(&in); err != nil {
					return nil, err
				}
				t.PtrParam(&in)
				return nil, nil
			},
		},
	}
}
`
)

func TestApi(t *testing.T) {
	_ = os.MkdirAll("test", 0o775)
	defer os.RemoveAll("test")
	if err := os.WriteFile(filepath.Join("test", "types.go"), []byte(testApiData), 0o664); err != nil {
		t.Fatal(err)
	}
	decls, err := zcore.ParseFileOrDirectory(filepath.Join("test", "types.go"), zcore.AnnotationPrefix)
	if err != nil {
		return
	}
	plugin := &Api{}
	if err = plugin.Run(decls.Parse(plugin, nil)); err != nil {
		t.Fatal(err)
	}
	data, err := ioutil.ReadFile(filepath.Join("test", "zzgen.api.go"))
	if err != nil {
		t.Fatal(err)
	}
	if !bytes.Equal(data, []byte(testApiRetData)) {
		t.Fatal(err)
	}
}
