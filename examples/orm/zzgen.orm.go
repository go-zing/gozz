// Code generated by gozz:orm. DO NOT EDIT.

package orm

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

var (
	_ = (*context.Context)(nil)
	_ = (*json.RawMessage)(nil)
	_ = (*time.Time)(nil)
	_ = (*sql.NullString)(nil)
)

var tables = []interface{}{
	Events{},
	Schemata{},
}

// information_schema.EVENTS
const TableEvents = "EVENTS"

type Events struct {
	// EVENT_CATALOG : NULLABLE varchar(64)
	EventCatalog *string
	// EVENT_SCHEMA : NULLABLE varchar(64)
	EventSchema *string
	// EVENT_NAME : varchar(64)
	EventName string
	// DEFINER : varchar(288)
	Definer string
	// TIME_ZONE : varchar(64)
	TimeZone string
	// EVENT_BODY : varchar(3)
	EventBody string
	// EVENT_DEFINITION : longtext
	EventDefinition string
	// EVENT_TYPE : varchar(9)
	EventType string
	// EXECUTE_AT : NULLABLE datetime
	ExecuteAt sql.NullTime
	// INTERVAL_VALUE : NULLABLE varchar(256)
	IntervalValue *string
	// INTERVAL_FIELD : NULLABLE enum('YEAR','QUARTER','MONTH','DAY','HOUR','MINUTE','WEEK','SECOND','MICROSECOND','YEAR_MONTH','DAY_HOUR','DAY_MINUTE','DAY_SECOND','HOUR_MINUTE','HOUR_SECOND','MINUTE_SECOND','DAY_MICROSECOND','HOUR_MICROSECOND','MINUTE_MICROSECOND','SECOND_MICROSECOND')
	IntervalField sql.NullString
	// SQL_MODE : set('REAL_AS_FLOAT','PIPES_AS_CONCAT','ANSI_QUOTES','IGNORE_SPACE','NOT_USED','ONLY_FULL_GROUP_BY','NO_UNSIGNED_SUBTRACTION','NO_DIR_IN_CREATE','NOT_USED_9','NOT_USED_10','NOT_USED_11','NOT_USED_12','NOT_USED_13','NOT_USED_14','NOT_USED_15','NOT_USED_16','NOT_USED_17','NOT_USED_18','ANSI','NO_AUTO_VALUE_ON_ZERO','NO_BACKSLASH_ESCAPES','STRICT_TRANS_TABLES','STRICT_ALL_TABLES','NO_ZERO_IN_DATE','NO_ZERO_DATE','ALLOW_INVALID_DATES','ERROR_FOR_DIVISION_BY_ZERO','TRADITIONAL','NOT_USED_29','HIGH_NOT_PRECEDENCE','NO_ENGINE_SUBSTITUTION','PAD_CHAR_TO_FULL_LENGTH','TIME_TRUNCATE_FRACTIONAL')
	SqlMode []string
	// STARTS : NULLABLE datetime
	Starts sql.NullTime
	// ENDS : NULLABLE datetime
	Ends sql.NullTime
	// STATUS : enum('ENABLED','DISABLED','SLAVESIDE_DISABLED')
	Status string
	// ON_COMPLETION : varchar(12)
	OnCompletion string
	// CREATED : timestamp
	Created time.Time
	// LAST_ALTERED : timestamp
	LastAltered time.Time
	// LAST_EXECUTED : NULLABLE datetime
	LastExecuted sql.NullTime
	// EVENT_COMMENT : varchar(2048)
	EventComment string
	// ORIGINATOR : int unsigned
	Originator uint
	// CHARACTER_SET_CLIENT : varchar(64)
	CharacterSetClient string
	// COLLATION_CONNECTION : varchar(64)
	CollationConnection string
}

func (Events) TableName() string { return TableEvents }

func (m *Events) FieldMapping() map[string]interface{} {
	return map[string]interface{}{
		"EVENT_CATALOG":        &m.EventCatalog,
		"EVENT_SCHEMA":         &m.EventSchema,
		"EVENT_NAME":           &m.EventName,
		"DEFINER":              &m.Definer,
		"TIME_ZONE":            &m.TimeZone,
		"EVENT_BODY":           &m.EventBody,
		"EVENT_DEFINITION":     &m.EventDefinition,
		"EVENT_TYPE":           &m.EventType,
		"EXECUTE_AT":           &m.ExecuteAt,
		"INTERVAL_VALUE":       &m.IntervalValue,
		"INTERVAL_FIELD":       &m.IntervalField,
		"SQL_MODE":             &m.SqlMode,
		"STARTS":               &m.Starts,
		"ENDS":                 &m.Ends,
		"STATUS":               &m.Status,
		"ON_COMPLETION":        &m.OnCompletion,
		"CREATED":              &m.Created,
		"LAST_ALTERED":         &m.LastAltered,
		"LAST_EXECUTED":        &m.LastExecuted,
		"EVENT_COMMENT":        &m.EventComment,
		"ORIGINATOR":           &m.Originator,
		"CHARACTER_SET_CLIENT": &m.CharacterSetClient,
		"COLLATION_CONNECTION": &m.CollationConnection,
	}
}

type SliceEvents []Events

func (s *SliceEvents) Range(f func(interface{}, bool) bool) {
	for i := 0; ; i++ {
		if c := i >= len(*s); !c {
			if !f(&(*s)[i], c) {
				return
			}
		} else if n := append(*s, Events{}); f(&n[i], c) {
			*s = n
		} else {
			*s = n[:i]
			return
		}
	}
}

// information_schema.SCHEMATA
const TableSchemata = "SCHEMATA"

type Schemata struct {
	// CATALOG_NAME : NULLABLE varchar(64)
	CatalogName *string
	// SCHEMA_NAME : NULLABLE varchar(64)
	SchemaName *string
	// DEFAULT_CHARACTER_SET_NAME : varchar(64)
	DefaultCharacterSetName string
	// DEFAULT_COLLATION_NAME : varchar(64)
	DefaultCollationName string
	// SQL_PATH : NULLABLE binary(0)
	SqlPath []byte
	// DEFAULT_ENCRYPTION : enum('NO','YES')
	DefaultEncryption string
}

func (Schemata) TableName() string { return TableSchemata }

func (m *Schemata) FieldMapping() map[string]interface{} {
	return map[string]interface{}{
		"CATALOG_NAME":               &m.CatalogName,
		"SCHEMA_NAME":                &m.SchemaName,
		"DEFAULT_CHARACTER_SET_NAME": &m.DefaultCharacterSetName,
		"DEFAULT_COLLATION_NAME":     &m.DefaultCollationName,
		"SQL_PATH":                   &m.SqlPath,
		"DEFAULT_ENCRYPTION":         &m.DefaultEncryption,
	}
}

type SliceSchemata []Schemata

func (s *SliceSchemata) Range(f func(interface{}, bool) bool) {
	for i := 0; ; i++ {
		if c := i >= len(*s); !c {
			if !f(&(*s)[i], c) {
				return
			}
		} else if n := append(*s, Schemata{}); f(&n[i], c) {
			*s = n
		} else {
			*s = n[:i]
			return
		}
	}
}
